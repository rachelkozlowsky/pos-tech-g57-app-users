name: CI/CD
on:
  push:
  workflow_dispatch:
    inputs:
      run_validation_and_lint:
        description: 'Executar Validation & Code Quality'
        required: false
        default: true
        type: boolean
      run_build:
        description: 'Executar Build Maven'
        required: false
        default: true
        type: boolean
      run_unit_test:
        description: 'Executar Testes Unit√°rios'
        required: false
        default: true
        type: boolean
      run_docker_build_and_push:
        description: 'Executar Build e Push do Docker'
        required: false
        default: true
        type: boolean
      run_deploy:
        description: 'Executar Deploy'
        required: false
        default: true
        type: boolean
jobs:
  validation-and-lint:
    name: Validation & Code Quality
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.run_validation_and_lint)
    steps:
      - uses: actions/checkout@v3
        with: 
          fetch-depth: 0

      - name: Verify Required Variables and Secrets
        run: |
          echo "üîç Verificando vari√°veis e secrets necess√°rios..."
          
          # Lista de vari√°veis obrigat√≥rias
          REQUIRED_VARS=(
            "APP_NAME"
            "DOCKERHUB_USERNAME" 
            "CLUSTER_NAME"
            "REGION_AWS_DEPLOY"
            "DOMAIN_NAME"
          )
          
          # Lista de secrets obrigat√≥rios
          REQUIRED_SECRETS=(
            "DOCKERHUB_TOKEN"
            "AWS_ACCESS_KEY_ID"
            "AWS_SECRET_ACCESS_KEY"
            "AWS_ACCESS_KEY"
            "AWS_SECRET_KEY"
            "JWT_TOKEN_PIX_APPLICATION_PAYMENT"
            "JWT_SECRET"
            "CLOUDFLARE_EDIT_ZONE_DNS_KEY"
          )
          
          echo "üìã Verificando vari√°veis..."
          MISSING_VARS=()
          for var in "${REQUIRED_VARS[@]}"; do
            case $var in
              "APP_NAME")
                if [ -z "${{ vars.APP_NAME }}" ]; then
                  MISSING_VARS+=("$var")
                else
                  echo "‚úÖ $var: ${{ vars.APP_NAME }}"
                fi
                ;;
              "DOCKERHUB_USERNAME")
                if [ -z "${{ vars.DOCKERHUB_USERNAME }}" ]; then
                  MISSING_VARS+=("$var")
                else
                  echo "‚úÖ $var: ${{ vars.DOCKERHUB_USERNAME }}"
                fi
                ;;
              "CLUSTER_NAME")
                if [ -z "${{ vars.CLUSTER_NAME }}" ]; then
                  MISSING_VARS+=("$var")
                else
                  echo "‚úÖ $var: ${{ vars.CLUSTER_NAME }}"
                fi
                ;;
              "REGION_AWS_DEPLOY")
                if [ -z "${{ vars.REGION_AWS_DEPLOY }}" ]; then
                  MISSING_VARS+=("$var")
                else
                  echo "‚úÖ $var: ${{ vars.REGION_AWS_DEPLOY }}"
                fi
                ;;
              "DOMAIN_NAME")
                if [ -z "${{ vars.DOMAIN_NAME }}" ]; then
                  MISSING_VARS+=("$var")
                else
                  echo "‚úÖ $var: ${{ vars.DOMAIN_NAME }}"
                fi
                ;;
            esac
          done
          
          echo "üîê Verificando secrets..."
          MISSING_SECRETS=()
          for secret in "${REQUIRED_SECRETS[@]}"; do
            case $secret in
              "DOCKERHUB_TOKEN")
                if [ -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
                  MISSING_SECRETS+=("$secret")
                else
                  echo "‚úÖ $secret: [REDACTED]"
                fi
                ;;
              "AWS_ACCESS_KEY_ID")
                if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
                  MISSING_SECRETS+=("$secret")
                else
                  echo "‚úÖ $secret: [REDACTED]"
                fi
                ;;
              "AWS_SECRET_ACCESS_KEY")
                if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
                  MISSING_SECRETS+=("$secret")
                else
                  echo "‚úÖ $secret: [REDACTED]"
                fi
                ;;
              "JWT_TOKEN_PIX_APPLICATION_PAYMENT")
                if [ -z "${{ secrets.JWT_TOKEN_PIX_APPLICATION_PAYMENT }}" ]; then
                  MISSING_SECRETS+=("$secret")
                else
                  echo "‚úÖ $secret: [REDACTED]"
                fi
                ;;
              "JWT_SECRET")
                if [ -z "${{ secrets.JWT_SECRET }}" ]; then
                  MISSING_SECRETS+=("$secret")
                else
                  echo "‚úÖ $secret: [REDACTED]"
                fi
                ;;
              "CLOUDFLARE_EDIT_ZONE_DNS_KEY")
                if [ -z "${{ secrets.CLOUDFLARE_EDIT_ZONE_DNS_KEY }}" ]; then
                  MISSING_SECRETS+=("$secret")
                else
                  echo "‚úÖ $secret: [REDACTED]"
                fi
                ;;
            esac
          done
          
          # Verificar se h√° vari√°veis ou secrets faltando
          if [ ${#MISSING_VARS[@]} -ne 0 ] || [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo ""
            echo "‚ùå ERRO: Vari√°veis ou secrets obrigat√≥rios n√£o foram encontrados!"
            
            if [ ${#MISSING_VARS[@]} -ne 0 ]; then
              echo ""
              echo "üìã Vari√°veis faltando:"
              for var in "${MISSING_VARS[@]}"; do
                echo "  - $var"
              done
              echo ""
              echo "Para adicionar vari√°veis:"
              echo "  1. V√° para Settings > Secrets and variables > Actions"
              echo "  2. Na aba 'Variables', clique em 'New repository variable'"
              echo "  3. Adicione cada vari√°vel listada acima"
            fi
            
            if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
              echo ""
              echo "üîê Secrets faltando:"
              for secret in "${MISSING_SECRETS[@]}"; do
                echo "  - $secret"
              done
            fi
            
            exit 1
          else
            echo ""
            echo "‚úÖ Todas as vari√°veis e secrets necess√°rios est√£o configurados!"
            echo ""
          fi

      - name: Lint Dockerfile
        run: |
          echo "üîç Verificando qualidade do Dockerfile..."
          
          # Verificar se o Dockerfile existe
          if [ ! -f "Dockerfile" ]; then
            echo "‚ùå ERRO: Dockerfile n√£o encontrado no reposit√≥rio"
            exit 1
          fi
          
          echo "‚úÖ Dockerfile encontrado"
          
          # Instalar hadolint se n√£o estiver dispon√≠vel
          if ! command -v hadolint &> /dev/null; then
            echo "üì¶ Instalando hadolint..."
            wget -O hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
            chmod +x hadolint
            sudo mv hadolint /usr/local/bin/
          fi
          
          echo "üîç Executando lint no Dockerfile..."
          hadolint Dockerfile

  build:
    runs-on: ubuntu-latest
    needs: validation-and-lint
    if: (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.run_build)) && (always() && (needs.validation-and-lint.result == 'success' || needs.validation-and-lint.result == 'skipped'))
    steps:
      - uses: actions/checkout@v3
        with: 
          fetch-depth: 0

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Build Maven project
        run: mvn clean package -DskipTests

  unit-test:
    runs-on: ubuntu-latest
    needs: build
    if: (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.run_unit_test)) && (always() && (needs.build.result == 'success' || needs.build.result == 'skipped'))
    steps:
    - uses: actions/checkout@v3
      with: 
        fetch-depth: 0

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '21'

    - run: mvn test

    - name: Gerar relat√≥rio Jacoco
      run: mvn jacoco:report
    
    - name: Generate Jacoco Badge
      id: jacoco
      uses: cicirello/jacoco-badge-generator@v2.0.1
    - name: Log coverage percentage
      run: |
        echo "Coverage percentage: ${{ steps.jacoco.outputs.coverage }}"
        echo "branch coverage: ${{ steps.jacoco.outputs.branches }}"

    - name: Upload Jacoco coverage report
      uses: actions/upload-artifact@v4
      with:
        name: jacoco-report
        path: target/site/jacoco/
  
  docker-build-and-push:
      runs-on: ubuntu-latest
      needs: unit-test
      if: (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && inputs.run_docker_build_and_push)) && (always() && (needs.unit-test.result == 'success' || needs.unit-test.result == 'skipped'))
      steps:
        - name: Checkout
          uses: actions/checkout@v4

        - name: Build Docker image
          run: |
            docker build -t ${{ vars.APP_NAME }}:latest .

        - name: Login to Docker Hub
          uses: docker/login-action@v3
          with:
            username: ${{ vars.DOCKERHUB_USERNAME }}
            password: ${{ secrets.DOCKERHUB_TOKEN }}

        - name: Tag Docker image for Docker Hub
          run: |
            docker tag ${{ vars.APP_NAME }}:latest ${{ vars.DOCKERHUB_USERNAME }}/${{ vars.APP_NAME }}:latest

        - name: Push Docker image to Docker Hub
          run: |
            docker push ${{ vars.DOCKERHUB_USERNAME }}/${{ vars.APP_NAME }}:latest

  deploy:
    runs-on: ubuntu-latest
    needs: [validation-and-lint, build, unit-test, docker-build-and-push]
    if: (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && inputs.run_deploy)) && always() && 
        (
          ((github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')) && needs.docker-build-and-push.result == 'success') ||
          (github.event_name == 'workflow_dispatch' && (
            needs.docker-build-and-push.result == 'success' || 
            needs.docker-build-and-push.result == 'skipped' ||
            !inputs.run_docker_build_and_push
          ))
        )
    steps:
      - uses: actions/checkout@v3
        with: 
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Update kube config
        run: |
          echo "üîç Verificando cluster EKS: ${{vars.CLUSTER_NAME}}"
          
          # Verificar se o cluster existe
          if ! aws eks describe-cluster --name ${{vars.CLUSTER_NAME}} --region ${{vars.REGION_AWS_DEPLOY}} >/dev/null 2>&1; then
            echo "‚ùå ERRO: Cluster EKS '${{vars.CLUSTER_NAME}}' n√£o encontrado na regi√£o ${{vars.REGION_AWS_DEPLOY}}"
            exit 1
          fi
          
          echo "‚úÖ Cluster encontrado, atualizando kubeconfig..."
          aws eks update-kubeconfig --name ${{vars.CLUSTER_NAME}} --region ${{vars.REGION_AWS_DEPLOY}}
          
          # Testar conectividade
          echo "üîç Testando conectividade com o cluster..."
          if ! kubectl get nodes >/dev/null 2>&1; then
            echo "‚ùå ERRO: N√£o foi poss√≠vel conectar ao cluster"
            echo "Verifique as permiss√µes IAM e a configura√ß√£o do cluster"
            exit 1
          fi
          
          echo "‚úÖ Conectado ao cluster com sucesso!"
          kubectl get nodes

      - name: Clean Previous Deployment
        run: |
          echo "üßπ Removendo recursos anteriores para garantir deploy limpo..."
          
          # Deletar todos os recursos do cluster de
          kubectl delete all --all
          
      - name: Deploy ConfigMap and Secret base
        run: |
          # Apply base ConfigMap and Secret first
          kubectl apply -f k8s/prd/configmap.yaml

      - name: Update ConfigMap and Secrets
        run: |
          
          # Update Secret with all sensitive data
          kubectl patch secret api-secret --patch "
          data:
            AWS_ACCESS_KEY: $(echo -n '${{ secrets.AWS_ACCESS_KEY_ID }}' | base64 -w 0)
            AWS_SECRET_KEY: $(echo -n '${{ secrets.AWS_SECRET_ACCESS_KEY }}' | base64 -w 0)
            JWT_TOKEN_PIX_APPLICATION_PAYMENT: $(echo -n '${{ secrets.JWT_TOKEN_PIX_APPLICATION_PAYMENT }}' | base64 -w 0)
            JWT_SECRET: $(echo -n '${{ secrets.JWT_SECRET }}' | base64 -w 0)
          "
          
          echo "‚úÖ Secret atualizado com dados sens√≠veis"

      - name: Deploy to AWS/EKS (Production)
        run: |
          echo "üöÄ Iniciando deploy dos recursos..."
          
          # Apply deployment first
          kubectl apply -f k8s/prd/deployment.yaml
        
          # Aplicar o Service processado
          kubectl apply -f k8s/prd/k8s-service.yaml

          # Aplicar Ingress
          kubectl apply -f k8s/prd/ingress.yaml
          
          # Aplicar outros recursos
          kubectl apply -f k8s/prd/hpa.yaml
          
          echo "‚úÖ Todos os recursos aplicados com sucesso!"

      # - name: Configure DNS Records and SSL
      #   env:
      #     CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_EDIT_ZONE_DNS_KEY }}
      #   run: |
      #     HOSTNAME=""
          
      #     echo "üåê Atualizando DNS no CloudFlare..."
          
      #     # Instalar jq se n√£o estiver dispon√≠vel
      #     if ! command -v jq &> /dev/null; then
      #       echo "üì¶ Instalando jq..."
      #       sudo apt-get update && sudo apt-get install -y jq
      #     fi
          
      #     # Configurar vari√°veis
      #     DOMAIN_NAME="${{ vars.DOMAIN_NAME }}"
      #     CF_API="https://api.cloudflare.com/client/v4"
          
      #     echo "üîç Obtendo Zone ID para $DOMAIN_NAME..."
          
      #     # Obter Zone ID
      #     ZONE_RESPONSE=$(curl -s -X GET "$CF_API/zones?name=$DOMAIN_NAME" \
      #       -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
      #       -H "Content-Type: application/json")
          
      #     ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id // empty')
          
      #     if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = "null" ]; then
      #       echo "‚ùå ERRO: Dom√≠nio $DOMAIN_NAME n√£o encontrado no CloudFlare"
      #       echo "üîß Verifique se o dom√≠nio foi adicionado ao CloudFlare"
      #       echo "Response: $ZONE_RESPONSE"
      #       exit 1
      #     fi
          
      #     echo "‚úÖ Zone ID encontrado: $ZONE_ID"
          
      #     # Verificar se registro api.domain.com j√° existe
      #     API_DOMAIN="api.$DOMAIN_NAME"
      #     echo "üîç Verificando registro existente para $API_DOMAIN..."
          
      #     EXISTING_RECORD=$(curl -s -X GET "$CF_API/zones/$ZONE_ID/dns_records?name=$API_DOMAIN&type=CNAME" \
      #       -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
      #       -H "Content-Type: application/json")
          
      #     RECORD_ID=$(echo "$EXISTING_RECORD" | jq -r '.result[0].id // empty')
          
      #     # Preparar dados do registro
      #     RECORD_DATA="{
      #       \"type\": \"CNAME\",
      #       \"name\": \"$API_DOMAIN\",
      #       \"content\": \"$HOSTNAME\",
      #       \"proxied\": true,
      #       \"ttl\": 300
      #     }"
          
      #     if [ -n "$RECORD_ID" ] && [ "$RECORD_ID" != "null" ]; then
      #       # Atualizar registro existente
      #       echo "üîÑ Atualizando registro CNAME existente..."
      #       UPDATE_RESPONSE=$(curl -s -X PUT "$CF_API/zones/$ZONE_ID/dns_records/$RECORD_ID" \
      #         -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
      #         -H "Content-Type: application/json" \
      #         -d "$RECORD_DATA")
      #     else
      #       # Criar novo registro
      #       echo "üìù Criando novo registro CNAME..."
      #       UPDATE_RESPONSE=$(curl -s -X POST "$CF_API/zones/$ZONE_ID/dns_records" \
      #         -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
      #         -H "Content-Type: application/json" \
      #         -d "$RECORD_DATA")
      #     fi
          
      #     # Verificar sucesso
      #     SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.success // false')
          
      #     if [ "$SUCCESS" = "true" ]; then
      #       echo "‚úÖ DNS atualizado com sucesso!"
      #       echo "üåê Registro: $API_DOMAIN ‚Üí $HOSTNAME"
      #       echo ""
      #       echo "üéâ Endpoints dispon√≠veis:"
      #       echo "  HTTPS: https://$API_DOMAIN/swagger-ui.html"
      #       echo "  HTTP:  http://$API_DOMAIN/swagger-ui.html"
      #       echo ""
      #       echo "‚è≥ DNS pode levar alguns minutos para propagar globalmente"
      #     else
      #       echo "‚ùå ERRO ao atualizar DNS:"
      #       echo "$UPDATE_RESPONSE" | jq -r '.errors[]?.message // "Erro desconhecido"'
      #       exit 1
      #     fi
          
      #     echo ""
      #     echo "‚úÖ Deploy e configura√ß√£o DNS conclu√≠dos!"